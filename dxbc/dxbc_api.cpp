#include "dxbc_api.h"

#include "../util/util_log.h"

namespace dxbc_spv::dxbc {

std::optional<ir::Builder> compileShaderToIr(const void* data, size_t size, const CompileOptions& options) {
  Container dxbc(util::ByteReader(data, size));

  if (!dxbc) {
    Logger::err("Failed to parse DXBC container.");
    return std::nullopt;
  }

  if (options.validateHash && !dxbc.validateHash()) {
    Logger::err("Invalid hash in DXBC binary.");
    return std::nullopt;
  }

  ir::Builder builder = { };

  Converter converter(dxbc, options.convertOptions);

  if (!converter.convertShader(builder)) {
    Logger::err("Failed to convert DXBC shader.");
    return std::nullopt;
  }

  return std::make_optional(std::move(builder));
}


void legalizeIr(ir::Builder& builder, const CompileOptions& options) {
  /* Convert to structured control flow and run SSA construction */
  ir::ConvertControlFlowPass::runPass(builder);
  ir::CleanupControlFlowPass::runPass(builder);
  ir::SsaConstructionPass::runPass(builder);

  /* Lower min-precision types */
  ir::LowerMin16Pass::runPass(builder, options.min16Options);

  /* Scalarize and eliminate redundant composite / consume instructions */
  ir::ScalarizePass::runPass(builder, options.scalarizeOptions);

  while (true) {
    bool progress = false;
    progress |= ir::LowerConsumePass::runResolveCastChainsPass(builder);
    progress |= ir::ScalarizePass::runResolveRedundantCompositesPass(builder);

    if (!progress)
      break;
  }

  /* Run type propagation for expressions and resources */
  ir::PropagateTypesPass::runPass(builder);
  ir::PropagateResourceTypesPass::runPass(builder, options.resourceOptions);

  /* Do a first round of removing unused code that may have been
   * generated by previous passes */
  ir::RemoveUnusedPass::runPass(builder);

  /* Lower ConsumeAs instructions to actual type casts and conversions */
  ir::LowerConsumePass::runLowerConsumePass(builder);

  /* Lower instructions that the target backend does not natively understand */
  ir::ArithmeticPass::runLoweringPasses(builder, options.arithmeticOptions);

  /* Run some basic code transforms */
  while (true) {
    bool progress = false;

    progress |= ir::ArithmeticPass::runPass(builder, options.arithmeticOptions);
    progress |= ir::LowerConsumePass::runResolveCastChainsPass(builder);
    progress |= ir::SsaConstructionPass::runResolveTrivialPhiPass(builder);

    if (!progress)
      break;

    ir::RemoveUnusedPass::runPass(builder);
  }
}


std::optional<ir::Builder> compileShaderToLegalizedIr(const void* data, size_t size, const CompileOptions& options) {
  auto builder = compileShaderToIr(data, size, options);

  if (!builder)
    return builder;

  legalizeIr(*builder, options);
  return builder;
}

}
